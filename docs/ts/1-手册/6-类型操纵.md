---
tags:
    - ts
---

# 类型操纵

TS 中有许多方法，来通过已有的类型定义一个新的类型。

## 泛型

```ts
function getLength<Type>(arr: Type[]) {
    return arr.length;
}

let output = getLength([1, 2, 3, 4]); // => 4
```

> 目前（v4.7.4），箭头函数的类型参数如果为单个的话，会被 TS 识别为 JSX 标签，因此会报错。

### 具化一个泛型函数

可以通过类型标注或传入类型参数来具化一个泛型函数：

```ts
let getNumericArrayLength: (arg: number[]) => number = getLength;
let getBooleanArrayLength = getLength<boolean>;
```

### 泛型类

```ts
class SomeKind<Type> {
    defaultValue?: Type;
    add?: (x: Type, y: Type) => Type;
}

let myNumber = new SomeKind<number>();
myNumber.defaultValue = 0;
myNumber.add = function (x, y) {
    return x + y;
};
```

在类中，类型参数是给实例用的，类自身的静态属性不可以使用类型参数。

## 类型约束

```ts
interface Identifiable {
    id: string | number;
}

function printID<Data extends Identifiable>(data: Data) {
    console.log(data.id);
}

printID({ id: 'zxcvb', name: 'Talaxy' }); // => 'zxcvb'
```

> 定义函数时应当考虑是否可以不用泛型，上述例子完全可以不用泛型。

一个类型参数可以约束另一个类型参数：

```ts
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3 };

getProperty(x, 'a'); // => 1
getProperty(x, 'm'); // ERROR: `"m"` 类型参数不可以赋值给 `"a" | "b" | "c"` 类型
```

### 将类作为形参

```ts
function create<Kind>(c: { new (): Kind }): Kind {
    return new c();
}

class Person {
    name?: string;
}

const person = create(Person);
person.name = 'Talaxy';
```

## `keyof` 类型操作符

## `typeof` 类型操作符

## 索引类型访问

## 条件类型

## 映射类型

## 模板字面量类型

## 参考

[Creating Types from Types - TypeScript](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)
