# 树

**树** 是 $n$ 个结点的有限集合，其中：

-   最多只有一个根结点；
-   除根结点外，其余结点可分为 $m$ 个 **互不相交** 的有限集 $T_1, T_2, ..., T_m$，其中每个集合本身又是一棵树，称为根的 **子树** 。

当 $n=0$ 时，称为 **空树** 。

若树中结点的各子树从左至右是有次序的，则称该树为 **有序树** ；否则称为 **无序树** 。

**m 叉树** ：每个结点最多有 $m$ 个子树的树。

**森林** 是 $m$ 棵互不相交的树的集合。

### 树的属性

**结点的度**：结点拥有的子树的个数，度为 $0$ 的结点称为 **叶子结点** ；

**结点的深度**：从根结点到该结点的唯一路径上的结点总数；

**结点的高度**：从该结点到一片树叶的最长路径上的结点总数；

**树的度**：树中所有结点的度的最大值；

**树的深度**：从根结点出发的最长路径上的结点总数。

### 常考性质

结点数 = 总度数 + 1（根结点）

度为 $m$ 的树中第 $i$ 层至多有 $m^{i-1}$ 个结点

高度为 $h$ 的 $m$ 叉树至多有 $m^0 + m^1 + m^2 + ... + m^{h-1}$ 个结点，即 $\frac{1 - m^h}{1- m}$ 个结点

高度为 $h$ 的 $m$ 叉树至少有 $h$ 个结点；高度为 $h$ 且度为 $m$ 的树至少有 $h+m-1$ 个结点

具有 $n$ 个结点的 $m$ 叉树的最小高度应当满足 $\frac{1 - m^{h-1}}{1- m} < n \leq \frac{1 - m^h}{1- m}$ ，即 $\lceil \log_m(n(m-1)+1) \rceil$

## 二叉树

**二叉树** 是每个结点最多有两个子树的有序树。其中，每个结点最多有两个子树，分别称为 **左子树** 和 **右子树** ，子树也是二叉树。

### 满二叉树

满二叉树是高度为 $h$ 且有 $2^h - 1$ 个结点的二叉树。特点有：

-   只有最后一层有叶子结点；
-   不存在度为 $1$ 的结点；
-   若按层从左到右编号，则编号为 $i$ 的结点，其左子树编号为 $2i$ ，右子树编号为 $2i+1$ 。

### 完全二叉树

从上到下、从左到右依次填满结点的二叉树即为完全二叉树。特点有：

-   只有最后两层可能有叶子结点；
-   最多只有一个度为 $1$ 的结点，且该结点只有左子树；
-   与满二叉树一致，编号为 $i$ 的结点，其左子树编号为 $2i$ ，右子树编号为 $2i+1$ 。

### 二叉排序树

二叉排序树是一种二叉树，且具有以下性质：

-   若左子树不为空，则左子树上所有结点的值均小于根结点的值；
-   若右子树不为空，则右子树上所有结点的值均大于根结点的值；
-   左、右子树也分别为二叉排序树。

### 平衡二叉树

平衡二叉树是一种二叉排序树，且树上任意结点的左、右子树的深度差不超过 $1$ 。

### 常考性质

设二叉树中结点总数为 $n$ ，度为 $i$ 的结点数为 $n_i$ ，有：

-   $n = n_0 + n_1 + n_2$
-   $n_0 = n_2 + 1$
-   完全二叉树中，$n_1 = 0$ 或 $1$

## 树的存储

### 二叉树的顺序存储

这样的存储方式适合完全二叉树，它能保证空间充分利用。

```cpp
#define MAX_SIZE 100
struct TreeNode {
    Element value;
    bool isEmpty;
}

int main() {
    TreeNode tree[MAX_SIZE];
    // ...
}
```

表中约定：

-   数组第一个元素可以抛弃，即从下标为 $1$ 开始存储；
-   结点 $i$ 的左孩子为 $2i$ ，右孩子为 $2i+1$ ；
-   结点 $i$ 的父结点为 $\lfloor \frac{i}{2} \rfloor$ ；
-   结点 $i$ 的深度为 $\lceil \log_2(i + 1) \rceil$ 。

对于结点数为 $n$ 的完全二叉树：

-   判断结点 $i$ 是否为叶子结点：$i \leq \lfloor \frac{n}{2} \rfloor$ ；
-   判断结点 $i$ 是否有左孩子：$2i \leq n$ ；
-   判断结点 $i$ 是否有右孩子：$2i+1 \leq n$ 。

### 二叉树的链式存储

```cpp
typedef struct TreeNode {
    Element value;
    TreeNode *left, *right;
} TreeNode, *Tree;
```

## 遍历

-   先序遍历：根左右
-   中序遍历：左根右
-   后序遍历：左右根
-   层次遍历：利用队列，从根结点开始，依次将左右孩子入队，然后出队，直到队列为空。

> 手算的请注意验证。

至少需要两种遍历才能确定一棵二叉树，且其中一种遍历必须是中序遍历。

## 线索二叉树

线索二叉树中，每个结点都有两个线索，分别指向（遍历序列中的）前驱和后继。

```cpp
typedef struct TreeThreadNode {
    Element value;
    TreeNode *left, *right;
    bool leftTag, rightTag;
} TreeThreadNode, *ThreadTree;
```

### 中序线索化

```cpp
void visit( ThreadTree tree, ThreadTree &pre) {
    if (!tree->left) {
        tree->left = pre;
        tree->leftTag = true;
    }
    if (pre && !pre->right) {
        pre->right = tree;
        pre->rightTag = true;
    }
    pre = tree;
}

void inThread(ThreadTree tree, ThreadTree &pre) {
    if (tree) {
        inThread(tree->left, pre);
        visit(tree, pre);
        inThread(tree->right, pre);
    }
}

void createThread(ThreadTree tree) {
    ThreadTree pre = NULL;
    if (tree) {
        inThread(tree, pre);
        // 处理最后一个结点
        pre->right = NULL;
        pre->rightTag = true;
    }
}
```
