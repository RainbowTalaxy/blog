# 查找

查找，即在数据集合中寻找一个特定的元素。

用于查找的数据集合称为 **查找表** ，它由同一类型的数据元素构成。

数据元素中用于唯一标识的属性称为 **关键字** ，基于关键字的查找结果应该是唯一的。

对于一个查找表，如果仅用来查找元素，则称为 **静态查找表** ；如果查找过程中同时插入或删除元素，称为 **动态查找表** 。

在查找运算中，需要比对关键字的次数称为 **查找长度** 。

所有查找过程中进行关键字比对的次数的平均值，称为 **平均查找长度** ，公式为 $ASL = \sum_{i=1}^n P_i C_i$ ，其中：

-  $P_i$ 为查找第 $i$ 个元素的概率；
-  $C_i$ 为第 $i$ 个元素的查找长度。

> 可以用 **查找判定树** 辅助分析平均查找长度。

## 顺序查找

使用顺序表存储数据，从头到尾依次遍历，直到找到目标元素。

时间复杂度为 $O(n)$ ，平均查找长度为 $\frac{n+1}{2}$ 。

## 折半查找

又称为 **二分查找** ，要求表内数据元素必须有序。

算法步骤如下：

0. 需要一个有序表 `s` 和两个指针 `low` 和 `high` ，分别指向表头和表尾。
1. 令 `mid = (low + high) / 2` ，将 `s[mid]` 与目标元素比较：
    - 若相等，则查找成功；
    - 若 `s[mid] > key` ，令 `high = mid - 1` ，重复步骤 1 ；
    - 若 `s[mid] < key` ，令 `low = mid + 1` ，重复步骤 1 。

时间复杂度为 $O(\log_2 n)$ 。

### 查找判定树

折半查找的查找判定树构建方法如下：

1. 拎出表中中间（向下取整）的元素，作为根节点，也是分界点；
2. 根据分界点，将表分为两部分，分别构建左右子树，并递归步骤 1 和 2 ；
3. 在所有叶子节点上补上两个结点，表示查找失败所在的数值区间。

上述方法所构建的查找判定树的特性：

- 满足平衡二叉树和二叉排序树的定义；
- 对于每个结点，其右子树的结点数最多比左子树多 1 个；
- 树高为 $\lfloor \log_2 n \rfloor + 1$（不含失败结点）。
- 若有 $n$ 个元素，则会有 $n + 1$ 个失败结点。

## 分块查找

在一个顺序表中，分组存放数据。同时建立一个索引表，记录每一组的索引开始的位置以及最大关键字。

> 如果为动态查找表，则可以用链式存储。

算法步骤如下：

1. 在索引表中查找目标元素所在的组；
2. 在该组中顺序查找目标元素。

如长度为 $n$ 的顺序表被分为 $m$ 组，每组 $b$ 个，若使用顺序查找方式查找索引表，则：

1. 索引查找的平均查找长度为 $(m + 1) / 2$ ，块内查找的平均查找长度为 $(b + 1) / 2$ ；
2. 总平均查找长度为两者相加：$(m + b) / 2 + 1$ ；
3. 当 $m = \sqrt{n}$ 时，此时每块为 $\sqrt{n}$ 个元素，总的平均查找长度最小，为 $\sqrt{n} + 1$ 。

> 如果用折半查找索引表，则 $ASL = \lceil \log_2 {m + 1} \rceil + (b + 1) / 2$ 。
