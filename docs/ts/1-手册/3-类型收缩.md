---
tags:
    - ts
---

# 类型具体化 Narrowing

类型具体化旨在我们应当对联合类型细分后再进行具体类型的应用：

```ts
function padLeft(padding: number | string, input: string) {
    // 括号内的语句被 TypeScript 称为 'type guard'，即"类型保护"
    if (typeof padding === 'number') {
        // 这里 TypeScript 会分析出 `padding` 是 `number` 类型
        return new Array(padding + 1).join(' ') + input;
    }
    // 这里 TypeScript 会分析出 `padding` 是 `string` 类型
    return padding + input;
}
```

这种类型检查特性会存在于各种控制流语句上，比如 `is/else`、三元条件语句、循环、真值检查等等。

## `typeof` 中的类型保护

`typeof` 是 JavaScript 里的操作符，能够再运行时里提供值类型信息。TypeScript 能够分析的 `typeof` 的返回值有：

-   `"string"`

-   `"number"`

-   `"bigint"`

-   `"boolean"`

-   `"symbol"`

-   `"undefined"`

-   `"object"`

-   `"function"`

TypeScript 有着自己的 `typeof` 处理，因为 JavaScript 中可能会存在一些奇怪的行为，比如 `null` 会被认为是 `object` 类型（实际上 `null` 自身是一种类型）：

```ts
function printAll(strs: string | string[] | null) {
    if (typeof strs === 'object') {
        // ERROR: 这里的 `strs` 也有可能是 `null`
        for (const s of strs) {
            console.log(s);
        }
    } else if (typeof strs === 'string') {
        console.log(strs);
    } else {
        // do nothing
    }
}
```

这里 `strs` 会被具体化为 `string[] | null` 而非仅仅是 `string[]` 。

> 对于上面的例子，VS Code（ver 1.57） 似乎并没有正确地进行类型检查，如果你用鼠标悬停在函数头的 `strs` 参数，VS Code 会显示 `(parameter) strs: string | string[]` ，而非官方文档里的 `(parameter) strs: string | string[] | null` 。

## 真值检查

在 JavaScript 里我们可以在条件语句、`&&`、`||`、`if` 语句或否定符 `!` 等里使用任何表达式。比如我们可以在 `if` 里放非 `boolean` 类型的条件语句。JavaScript 会将条件语句强制转为布尔值，比如这些值会被转为 `false` ：

-   `0`

-   `NaN`

-   `""`（空字符串）

-   `0n`（`bigint` 中的 0）

-   `null`

-   `undefined`

你也可以用 `Boolean` 函数将值转为布尔值，或者用双否定 `!!` 。而后者其实会推断为一个布尔值字面量类型（比如例子中为 `true` ），前者仅仅是个 `boolean` 类型：

```ts
Boolean('hello'); // type: boolean, value: true
!!'world'; // type: true,    value: true
```

> 在 VS Code（ver 1.57）中的实践中，我并没有发现 `!!"worlds"` 被认定为 `true` 类型的迹象，比如 `let b: true = !!"123"` 会报错 **不能将类型“boolean”分配给类型“true”。ts(2322)** 。

我们可以利用这一行为来进行空值检查：

```ts {2}
function printAll(strs: string | string[] | null) {
    if (strs && typeof strs === 'object') {
        for (const s of strs) {
            console.log(s);
        }
    } else if (typeof strs === 'string') {
        console.log(strs);
    }
}
```

但是请**不要**写成如下的例子，因为空字符串是 `string` 类型，但是会转为布尔值 `false` ：

```ts {2}
function printAll(strs: string | string[] | null) {
    if (strs) {
        if (typeof strs === 'object') {
            for (const s of strs) {
                console.log(s);
            }
        } else if (typeof strs === 'string') {
            console.log(strs);
        }
    }
}
```

当然，单个否定符 `!` 也是有效的：

```ts
function multiplyAll(
    values: number[] | undefined,
    factor: number,
): number[] | undefined {
    if (!values) {
        return values;
    } else {
        return values.map((x) => x * factor);
    }
}
```

## 参考

[Narrowing - TypeScript](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
